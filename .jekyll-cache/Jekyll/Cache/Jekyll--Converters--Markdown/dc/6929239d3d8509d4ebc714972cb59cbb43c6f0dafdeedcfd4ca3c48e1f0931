I"—
<p>Note: Another good and related topic that I won‚Äôt cover in depth here/yet. Is how when building a codebase/system. You should be validating your input‚Äôs at the boundary of the system. Don‚Äôt litter every function you write with checks that variables are of a certain type.  If you want that you need to consider TypeScript or any other typed language. On the backend if you are fetching data from other systems you don‚Äôt own, you need to be rigorously validating it, On the frontend rigorously validating user input. Everything else in between needs to be rigorously checked via unit testing.</p>

<p>Note: I know it‚Äôs common for developers to ‚Äòreturn early‚Äô from functions or write ‚Äòguard clauses‚Äô.  I remain unconvinced.  But I do know several programmers that I respect that prefer this. So, maybe I will change my mind later or maybe I will change everyone elses mind.  https://softwareengineering.stackexchange.com/a/18459/36411</p>

<p>A common issue I see when reviewing code is developers using negative test cases when validating inputs</p>

<p>When validating input, use positive test cases, meaning test that the input/variable is the format you want rather than what you don‚Äôt want.  Consider which is more effective.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">comsumeUserInputGood</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">,</span> <span class="nx">fieldTwo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">fieldTwo</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">//execute behavior you want.</span>
      <span class="k">return</span> <span class="nx">fieldOne</span> <span class="o">+</span> <span class="nx">fieldTwo</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//execute exceptional case.</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">comsumeUserInputBad</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">,</span> <span class="nx">fieldTwo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">isNull</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">)</span> <span class="o">||</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isNull</span><span class="p">(</span><span class="nx">fieldTwo</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">//Handle the null case. Maybe there is something special you can do here.</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">_</span><span class="p">.</span><span class="nx">isUndefined</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">)</span> <span class="o">||</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isUndefined</span><span class="p">(</span><span class="nx">fieldTwo</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">//Handle the undefined case. Maybe there is something special you can do here.</span>
  <span class="p">}</span>
  <span class="c1">//execute behavior you want.</span>
  <span class="k">return</span> <span class="nx">fieldOne</span> <span class="o">+</span> <span class="nx">fieldTwo</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>I think the differences here are obvious</p>
<ul>
  <li>In the ‚Äúbad‚Äù case it‚Äôs more likely to break. Maybe it wont. Maybe your input field has type=number. So in practice you are dealing with null and numbers. Ok, that‚Äôs fine. The point is if you are going to be validating your input, positive test cases won‚Äôt let anything slip through the cracks.</li>
</ul>

<p>But there is another interesting side effect that should be discussed</p>
<ul>
  <li>In the ‚Äúgood‚Äù case we are propagating the most interesting code to the top of the function.  It‚Äôs what you probably need to be reading. It gets straight to the point. We need a number, then get on with what you‚Äôre going to do with it. Littering the top of the function with negative checks is everything I am not interested in.</li>
</ul>

<p>Another scenario that mixes the above but the point remains would be</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">comsumeUserInputGood</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">,</span> <span class="nx">fieldTwo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fieldOne</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">)</span> <span class="p">?</span> <span class="nx">fieldOne</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">fieldTwo</span> <span class="o">=</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isNumber</span><span class="p">(</span><span class="nx">fieldTwo</span><span class="p">)</span> <span class="p">?</span> <span class="nx">fieldTwo</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">fieldOne</span> <span class="o">+</span> <span class="nx">fieldTwo</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">comsumeUserInputBad</span><span class="p">(</span><span class="nx">fieldOne</span><span class="p">,</span> <span class="nx">fieldTwo</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">fieldOne</span> <span class="o">=</span> <span class="nx">fieldOne</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">fieldTwo</span> <span class="o">=</span> <span class="nx">fieldTwo</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">fieldOne</span> <span class="o">+</span> <span class="nx">fieldTwo</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>I don‚Äôt have to tell you an empty array or empty object would slip through the checks in the second function. <a href="https://github.com/denysdovhan/wtfjs#funny-math">Which could lead to some fun math.</a></p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="o">&gt;</span> <span class="p">{}</span> <span class="o">+</span> <span class="p">[]</span>
<span class="o">&gt;</span> <span class="mi">0</span></code></pre></figure>

<p>I hope I have sufficiently proved in most cases if you need to validate some input there is a good chance you should be using positive test cases.  If you have any exceptions that prove the rule, I would be interested to see them.</p>

:ET